window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pymmep", "modulename": "pymmep", "kind": "module", "doc": "<p>Short decription: A bundle of functions for working with the <a href=\"https://github.com/multimodal-europarl/mmep-corpus\"><code>mmep-corpus</code></a>.</p>\n"}, {"fullname": "pymmep.container", "modulename": "pymmep.container", "kind": "module", "doc": "<p>The point of this module is to hold the class SpeechContainer and as little\nelse as possible, so that it can run on as many platforms out of the box\nas possible.</p>\n"}, {"fullname": "pymmep.container.SpeechContainer", "modulename": "pymmep.container", "qualname": "SpeechContainer", "kind": "class", "doc": "<p>Description:</p>\n\n<p>This class is intended to hold all important values for one speech.</p>\n\n<p>This is intended to be created with the functions from eaf_utils,\nto parse all .eaf information into this python structure\nand save it pickled for later use.</p>\n\n<blockquote>\n  <p>The initialiser takes one argument: A touple containing\n  [0] path to eaf file\n  [1] dictionary of time info from eaf \n  [2] dictionary of tier info from eaf\n  [3] list of other eaf info\n  from here all relevant information is extracted.\n  This touple can be neatly prepared with extract_eaf() from eaf_utils\n  which requires only the path of an eaf file.</p>\n</blockquote>\n\n<blockquote>\n  <p>Add more data as you please using the speech_container_utils module.</p>\n</blockquote>\n\n<blockquote>\n  <p>Call method .to_pickle(Path) to save the whole object.</p>\n</blockquote>\n\n<p>====================\nAttributes (Top level overview):</p>\n\n<p>file_data : Dictionary of file paths.</p>\n\n<p>speech_data : Dictionary of information about the speech and the \n              recording.</p>\n\n<p>speaker_data : Dictionary of information about the speaker.</p>\n\n<p>_eaf_data : Dictionary of eaf data for full reconstruction.</p>\n\n<p>language_data : One dictionary for each language containing potential\n                eaf tiers.</p>\n\n<hr />\n\n<p>file_data:\n(set by the constructor)\n    mp3_paths : (Str) The path of the folder holding all mp3s.\n    eaf_path : (Str) The path to the eaf.\n    folder_name : (Str) The folder name for this recording without path.</p>\n\n<p>speech_data:\n(set by the constructor)\n    None\n(set manually)\n    samples : (Int) The number of samples of the original speech.\n    sample_rate : (Int) The sample rate of the original speech.\n    length : (Int) The length in milliseconds of the original speech.\n    orig_lang : (Str) The original language of the speech.\n        orig_lang_kaldi : Original language according to Kaldi,\n        orig_lang_zcr : Original language according to ocr,\n        zcr_data : Data the zcr decision is based on,\n        orig_lang_whisper : Original language according to whisper,\n        whisper_data : Data the whisper decision is based on,\n        orig_lang_sub : Original language according to subtraction,\n        sub_data : Data the sub decision is based on.\n    window : (Tuple of 2 Int) The window the original language is likely\n             spoken.\n    date : (Str) The date of the SESSION of the speech.\n    time : (Str) The approximate ACTUAL time of the speech.\n    session : (Int) The session number.\n    location : (Str) The location (Brussels or Strasbourg).\n    cycle : (Tuple of 2 Int) The numbers of the session and max sessions \n            within the cycle (Normally 4 in Strasbourg, 2 in Brussels).\n    subject : (Str) The subject of the block the speech is a part of.\n    chair: (Str) Person in the president's chair.</p>\n\n<p>speaker_data:\n(set by the constructor)\n    None\n(set manually)\n    name : (Str) The name of the speaker.\n    group : (Str) The group the speaker is affiliated with.\n    gender : (Str) The gender of the speaker.\n    birthday : (Str) The date of birth of the speaker.\n    age : (Int) The age of the speaker at the time of the speech.\n    native : (Bool) Information whether the speaker is speaking his native\n             language or not.\n    wiki : (Str) wikipedia link to the speaker's page. </p>\n\n<p>_eaf_data:\n(set by the constructor)\n    time_dictionary : (Dict of Str key and Int value) \n    eaf_duration : (Int)\n    date : (Str)\n    property_tag : (Str)</p>\n\n<p>language_data:\n(set by the constructor)\n    22 dictionaries, each containing:\n        df_transcription : The transcription tier from the eaf-file\n                           transcribed with Kaldi.\n        df_confidence : Kaldi's confidence in its transcription.\n        df_is_translation : Kaldi's estimation whether this segment is \n                            a translation.\n        df_manually_corrected : Info whether the segment has been manually\n                                corrected by a human.\n(set manually)\n        df_transcription_whisper1 : Transcription of the audio by whisper.\n        df_transcription_whisper2 : Transcription of the audio by whisper\n                                    after more training.\n        'relay_interp' : (Bool) Flag if this is a relay interpretation.\n        'retour_interp': (Bool) Flag if this is a retour interpretation.\n        'is_translation_perc' : (Float) Percentage of \n        'speech_duration' : (Int) Duration of the audio channel.\n        'verbatim_file' : (Int) Number of speech in verbatim dictionary.\n        'verbatim_speech' : (Str) Content of verbatim speech.\n        'verbatim_ratio' : (Float)Sequence matcher ratio that led to this\n                           match.\n        'interpreter_window' : Estimated window when the interpreter has \n                               his microphone active (based on channel\n                               subtraction).</p>\n\n<p>====================\nPublic Methods:</p>\n\n<p>to_pickle(directory = _output) : pickles the container, standard directory\n                                 is ./_output, but another one may be set.</p>\n\n<p>migrate() : extracts the contents of the container into a folder of the \n            same name. This only affects the attributes declares in this\n            module, but other attributes may be added to the folder after\n            calling migrate(). \n            Warning: This is very unweildly, but allows migrating the \n            structure to R or C++ or whatever is popular in 10 years.</p>\n\n<p>====================\nExample Usage:</p>\n"}, {"fullname": "pymmep.container.SpeechContainer.__init__", "modulename": "pymmep.container", "qualname": "SpeechContainer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf_extraction</span></span>)</span>"}, {"fullname": "pymmep.container.SpeechContainer.file_data", "modulename": "pymmep.container", "qualname": "SpeechContainer.file_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.container.SpeechContainer.speech_data", "modulename": "pymmep.container", "qualname": "SpeechContainer.speech_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.container.SpeechContainer.speaker_data", "modulename": "pymmep.container", "qualname": "SpeechContainer.speaker_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.container.SpeechContainer.language_data", "modulename": "pymmep.container", "qualname": "SpeechContainer.language_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.container.SpeechContainer.to_pickle", "modulename": "pymmep.container", "qualname": "SpeechContainer.to_pickle", "kind": "function", "doc": "<p>This method pickles the instance of SpeechContainer into a directory\nthat is its only parameter (standard is _output).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">directory</span><span class=\"o\">=</span><span class=\"s1\">&#39;_output&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.from_nothing", "modulename": "pymmep.container", "qualname": "SpeechContainer.from_nothing", "kind": "function", "doc": "<p>This creates an empty container which can then be refilled\nfrom an older container. Used for reordering and addition\nof attributes and methods. Kind of private, because it is\na little hacky with its use of strings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.migrate", "modulename": "pymmep.container", "qualname": "SpeechContainer.migrate", "kind": "function", "doc": "<p>This method extracts all information declared in this module into a\nfolder and file structure, so that it may be accessed with whatever\nprogram or language anyone could want. \nIts only parameter is the output folder (standard is _migration).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">directory</span><span class=\"o\">=</span><span class=\"s1\">&#39;_migration&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.get_file_info", "modulename": "pymmep.container", "qualname": "SpeechContainer.get_file_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.get_speech_info", "modulename": "pymmep.container", "qualname": "SpeechContainer.get_speech_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.get_speaker_info", "modulename": "pymmep.container", "qualname": "SpeechContainer.get_speaker_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.get_eaf_info", "modulename": "pymmep.container", "qualname": "SpeechContainer.get_eaf_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container.SpeechContainer.get_language_info", "modulename": "pymmep.container", "qualname": "SpeechContainer.get_language_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils", "modulename": "pymmep.container_utils", "kind": "module", "doc": "<p>The point of this module is to hold functions that are repeatedly\nused for container manipulation.</p>\n"}, {"fullname": "pymmep.container_utils.pickle_iterator", "modulename": "pymmep.container_utils", "qualname": "pickle_iterator", "kind": "function", "doc": "<p>yields all pickles in a folder</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pickle_dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;./pickled_containers&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.calculate_translation_perc", "modulename": "pymmep.container_utils", "qualname": "calculate_translation_perc", "kind": "function", "doc": "<p>This function takes a container and a language code and returns\nthe language's Kaldi estimation of the percentage of translated \nand non-translated speech in a touple of two floats.</p>\n\n<p>input: container (with eaf info), language_code\noutput: If eaf_duration = 0: None\n        If no segment with translation value: None\n        Else: (Float, Float)\n        The first float is the % of translated speech.\n        The second float is the % of non translated speech.\n        (This does not necessarily add up to 100% because\n        of silence)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">container</span>, </span><span class=\"param\"><span class=\"n\">language_code</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.set_orig_lang_kaldi", "modulename": "pymmep.container_utils", "qualname": "set_orig_lang_kaldi", "kind": "function", "doc": "<p>This function takes a container, iterates over all languages and collects\nall is_translation_perc values. It stores these values in kaldi_data and\nsets orig_lang_kaldi according to the winner with an added reliability \nmeasure.</p>\n\n<p>input: container (with eaf info and is_translated_perc set)\noutput: (tuple, string, float) \n        Sorted tuple of all languages' is_translation_perc and \n        The language string with the highest percentage of non-translated \n        segments and \n        the distance to number two.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">container</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.calculate_zcr_reliability", "modulename": "pymmep.container_utils", "qualname": "calculate_zcr_reliability", "kind": "function", "doc": "<p>This returns true if \"und\" and the best estimate are closer than\nthe the second best estimate and either \"und\" or the best estimate.\n(It was established that \"und\" has to be in the top 2.)</p>\n\n<p>Input: Entry of zcr-dictionary of the form [(estimate), [(), (), ...]]\nOutput: True or False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zcr_data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.estimate_orig_lang_whisper", "modulename": "pymmep.container_utils", "qualname": "estimate_orig_lang_whisper", "kind": "function", "doc": "<p>Returns a list of all languages reliably identified within the \nrecording, ordered by amount of window occurrences (first run\nused 10 second windows in 3 second steps.</p>\n\n<p>Input: List of whisper language estimates of the form\n        ['language', reliable?, [full data]]\nOutput: Ordered list of the sum of reliably identified \n        language sections.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">current_whisper</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.estimate_orig_lang_sub", "modulename": "pymmep.container_utils", "qualname": "estimate_orig_lang_sub", "kind": "function", "doc": "<p>Takes second-wise estimate of interpreter activity and returns \nthe most likely main language, duration and confidence measure.</p>\n\n<p>Input: Dictionary of language:second_wise_interaction_boolean\nOutput: Main language, Seconds of interpreter inactivity,\n        confidence measure between 0 and 1, unlikely &gt; 0.8</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">action</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.set_session_data", "modulename": "pymmep.container_utils", "qualname": "set_session_data", "kind": "function", "doc": "<p>This sets the session specific information according to a session\nlist provided.</p>\n\n<p>Input: Session list containing (session_start, session_end, \n        location code, and number of sessions in cycle.\nOutput: None, sets attributes in container.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">container</span>, </span><span class=\"param\"><span class=\"n\">session_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.set_subject", "modulename": "pymmep.container_utils", "qualname": "set_subject", "kind": "function", "doc": "<p>This sets the speech subject according to the time stamp\nfrom filename and a start + end + subject name list provided.</p>\n\n<p>Input: List containing (subject_start, subject_end, subject) <br />\nOutput: None, sets attributes in container.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">container</span>, </span><span class=\"param\"><span class=\"n\">subject_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.container_utils.set_chair_from_time", "modulename": "pymmep.container_utils", "qualname": "set_chair_from_time", "kind": "function", "doc": "<p>This sets the person currently in the chair according\nto chair changes from the verbatim report time stamps.\nThis is not precise !</p>\n\n<p>Input: container, list of chair changes <br />\nOutput: person in chair</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">container</span>, </span><span class=\"param\"><span class=\"n\">chair_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container", "modulename": "pymmep.eaf_container", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container", "kind": "class", "doc": "<p>This class is intended to hold all important values from an .eaf file.\nIt will also hold a lot of additional information that would not fit neatly into an .eaf file.</p>\n\n<p>This is intended to be used with the iterator from eaf_utils,\nto parse all .eaf information into a python structure\n(and save it pickled for later use).</p>\n\n<p>The constructor takes four arguments: the path to the .eaf file, and the results of \"prepare_eaf(path)\", \nfrom here all relevant information is extracted.\nCall method .to_pickle(Path) to save the whole object.</p>\n\n<p>====================\nParameters of Constructor: __init__(path, time_dictionary, tier_dictionary, deco)</p>\n\n<p>path : String</p>\n\n<p>slot_dic : Dictionary of eaf time data; provided by prepare_eaf(path)</p>\n\n<p>tier_dic : Dictionary of eaf tiers; provided by prepare_eaf(path)</p>\n\n<p>deco : List of two Strings; provided by prepare_eaf(path)</p>\n\n<p>====================\nAttributes:</p>\n\n<p>lannguage_data : The dictionary that holds the language individual data &lt;-- this is likely what you are here for. The keys are the 3-letter language codes.</p>\n\n<pre><code>bul bulgarian\ncze czech\ndan danish\ndut dutch\neng english\nest estonian\nfin finnish\nfra french\nger german\ngre greek\nhun hungarian\nita italian\nlav latvian\nlit lithuanian\nmlt maltese\npol polish\npor portuguese\nrum romanian\nslo slovakian\nslv slovenian\nspa spanish\nswe swedish\n\nthe value of each key is another dictionary that holds the transcriptions, verbatim_reports, metadata and everything else I can find. The UML contains all keys.\n</code></pre>\n\n<p>path : The path to the .eaf file as Path</p>\n\n<p>time_dictionary : The TIME_ORDER block from the .eaf file (hash table for time values) as Dictionary.</p>\n\n<p>original_language : The language the speech was delivered in as 3 letter String. (determined by sequence matcher)</p>\n\n<p>speaker_name : The speaker's full name, speaker_name[0] being the first name, speaker_name[-1] being the last name.</p>\n\n<p>speaker_is_native : Info whether the speaker was considered speaking in his native language as Bool.</p>\n\n<p>speaker_birth : Info on the age of the speaker as Int.</p>\n\n<p>speaker_gender : Info on the gender of the speaker as 1 letter String.</p>\n\n<p>speaker_affiliation : Info on the group the speaker is speaking for as String.</p>\n\n<p>eaf_duration : Duration of the .eaf file in milliseconds as Int.</p>\n\n<p>mp3_paths : ---not implemented---</p>\n\n<p>_original_language_zcr : The language the speech was delivered in as 3 letter String. (determined by zcr)</p>\n\n<p>_filename : The filename without the .eaf as String</p>\n\n<p>_deco1 : ANNOTATION_DOCUMENT tag as String</p>\n\n<h1 id=\"_deco2-property-nameurn-tag-as-string\">_deco2 : PROPERTY NAME=\"URN\" tag as String</h1>\n\n<p>Methods:</p>\n\n<p>@staticmethod\nprepare_eaf(path) : This function calls several functions of pymmep.eaf_utils to prepare the data\n    necessary to construct the Eaf_Container. The arguments can not be provided as list, so kindly\n    write a[0], a[1], a[2] until I find a better way to only parse the xml once.</p>\n\n<p>describe() : Sums up the most important information about the speech (not yet implemented)</p>\n\n<p>====================\nExample Usage:</p>\n\n<p>arguments = prepare_eaf(\"./files/file.eaf\")\neaf = Eaf_Container(\"./files/file.eaf\", arguments[0], arguments[1], arguments[2])\neaf.to_pickle()</p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.__init__", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">time_dictionary</span>, </span><span class=\"param\"><span class=\"n\">tier_dictionary</span>, </span><span class=\"param\"><span class=\"n\">deco</span></span>)</span>"}, {"fullname": "pymmep.eaf_container.Eaf_Container.path", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.time_dictionary", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.time_dictionary", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.eaf_duration", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.eaf_duration", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.speaker_name", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.speaker_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.original_language", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.original_language", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.speaker_is_native", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.speaker_is_native", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.speaker_birth", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.speaker_birth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.speaker_gender", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.speaker_gender", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.speaker_affiliation", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.speaker_affiliation", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.language_data", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.language_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pymmep.eaf_container.Eaf_Container.prepare_eaf", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.prepare_eaf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.make_dataframe_from_path_to_eaf", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.make_dataframe_from_path_to_eaf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.make_big_dataframe", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.make_big_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">code</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.make_duration_column", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.make_duration_column", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.to_pickle", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.to_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">outpath</span><span class=\"o\">=</span><span class=\"s1\">&#39;./_output/</span><span class=\"si\">{}</span><span class=\"s1\">.pickle&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.remake_eaf", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.remake_eaf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_container.Eaf_Container.describe", "modulename": "pymmep.eaf_container", "qualname": "Eaf_Container.describe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils", "modulename": "pymmep.eaf_utils", "kind": "module", "doc": "<p>Utilities relating to eaf transcription files.</p>\n"}, {"fullname": "pymmep.eaf_utils.eaf_iterator", "modulename": "pymmep.eaf_utils", "qualname": "eaf_iterator", "kind": "function", "doc": "<p>Returns an iterator of transcription file paths.</p>\n\n<p>kwargs:</p>\n\n<ul>\n<li><code>tx_dir</code>: root directory of trannscriptions</li>\n<li><code>start</code>: from yyyymm</li>\n<li><code>end</code>: to (incl) yyyymm</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tx_dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;mmep-corpus/transcribed-audio&#39;</span>, </span><span class=\"param\"><span class=\"n\">start</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">end</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.get_decoration", "modulename": "pymmep.eaf_utils", "qualname": "get_decoration", "kind": "function", "doc": "<p>Takes the last two pieces of information exclusive to the .eaf from the\nHeader and Property.\nWith this all information can now be extracted from the .eaf.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.get_media_descriptors", "modulename": "pymmep.eaf_utils", "qualname": "get_media_descriptors", "kind": "function", "doc": "<p>Take an eaf tree object and return <MEDIA_DESCRIPTOR> elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.get_tiers", "modulename": "pymmep.eaf_utils", "qualname": "get_tiers", "kind": "function", "doc": "<p>Return Tier elems from eaf tree.</p>\n\n<p>kwargs:</p>\n\n<ul>\n<li><code>tx_only</code>: return only transcription tiers</li>\n<li><code>language</code>: return tier of language (not implemented)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf</span>, </span><span class=\"param\"><span class=\"n\">tx_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">language</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.get_time_slots", "modulename": "pymmep.eaf_utils", "qualname": "get_time_slots", "kind": "function", "doc": "<p>Return time_slot elems from eaf tree.</p>\n\n<p>Input: lxml.etree._Element from get.root(); as delivered by parse_eaf() in this module\nOutput: [lxml.etree._Element], Elements with tag TIME_SLOT</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.make_tier_dictionary", "modulename": "pymmep.eaf_utils", "qualname": "make_tier_dictionary", "kind": "function", "doc": "<p>Takes a list of tiers and returns a dictionary containing their IDs as keys and\nthe original tier as value.\nThis is very helpful for editing multiple, but not all tiers.</p>\n\n<p>Input: [lxml.etree._Element] with tag TIER and attributes 'TIER_ID'\nOUTPUT:  {'ID': value}\n    Keys are strings\n    Values are lxml.etree._Element</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tierlist</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.make_time_slot_dictionary", "modulename": "pymmep.eaf_utils", "qualname": "make_time_slot_dictionary", "kind": "function", "doc": "<p>Takes a list of time slots and returns a dictionary containing their IDs as keys and\ntime values in milliseconds as values.</p>\n\n<p>Input: [lxml.etree._Element] with tag TIME_SLOT and attributes 'TIME_SLOT_ID' and\n'TIME_VALUE'; as delivered by get_time_slots() in this module\nOutput: {'ID': Value}\n    Keys are strings\n    Values are ints</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time_slot_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.parse_eaf", "modulename": "pymmep.eaf_utils", "qualname": "parse_eaf", "kind": "function", "doc": "<p>Returns eaf etree object from the eaf_path.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.extract_eaf", "modulename": "pymmep.eaf_utils", "qualname": "extract_eaf", "kind": "function", "doc": "<p>Takes the path of an eaf and extracts all information using this module's functions.</p>\n\n<p>First calls parse_eaf() on the path to receive the tree.\nFrom the tree it extracts and returns \nthe {time slot information}, the {tier information}, the [date, first property text].</p>\n\n<p>Input: path to eaf\nOutput: (path, {dictionary of time slots}, {dictionary of tiers}, \n         [list of date, first property text information])</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pymmep.eaf_utils.write_eaf", "modulename": "pymmep.eaf_utils", "qualname": "write_eaf", "kind": "function", "doc": "<p>Writes eaf tree (<code>eaf</code>) to file (<code>eaf_path</code>).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eaf</span>, </span><span class=\"param\"><span class=\"n\">eaf_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();